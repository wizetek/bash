#!/bin/bash

#
# corecleaner
#
# Find and remove 'core' files
# 2018-04-27 Tom Wizetek
#

_LIST="/tmp/$(basename $0)-${USER}.list"
_LEVEL='/home'
_ACTION='rm --interactive'

usage()
{
  cat << _USAGE

Usage:   $(basename $0) [option] [path]

Options:

  -f, --force         remove without confirmation
  -l, -ls, --list     search and list only, don't remove
  -a, --all           don't search, show all previous matches and file sizes
                      (no file type and permissions verification)
  -h, --help          this help

/home is the default path if not specified.
Search results are saved in /tmp/$(basename $0)-<user>.list

_USAGE
}

examples()
{
  cat << _EXAMPLES
Examples:

  $(basename $0)         search in /home and ask before removing each file
  $(basename $0) -f      look in /home and remove without asking
  $(basename $0) -l /    only list results from /
  $(basename $0) -a      show last unverified matches

_EXAMPLES
}

case $1 in
  -f|--force)
  _ACTION='rm --force --verbose'
  shift
;;
  -l|-ls|--list)
  _ACTION='echo'
  shift
;;
  -a|--all)
  if [ -f ${_LIST} ]
  then
    xargs -r -a ${_LIST} -d "\n" ls -shS1
    exit 0
  else
    echo "Run a search without $1 first to generate a list."
    usage
    exit 1
  fi
;;
  -h|--help)
  usage
  examples
  exit 0
;;
esac

# Is there a path argument?
if [[ $1 != "" ]]
then
  # Is it a valid directory?
  if [ -d $1 ]
  then
    _LEVEL=$1
  else
    echo "Invalid argument"
    usage
    exit 1
  fi
fi

echo -n "Finding 'core' files..."
# Find files named core or core.1(...)
find ${_LEVEL} -type f -name 'core' -fprint ${_LIST} -o -type f -regex '.*/core\.[0-9]*' -fprint ${_LIST} 2>/dev/null
echo -e " done\n"

# Prevent loop split on spaces in path
_OLDIFS=$IFS
IFS=$'\n'

for _CORE in $(cat ${_LIST})
do
  # Is it really core?
  _TYPE=$(file "${_CORE}" | grep -o 'core file')
  if [[ $_TYPE != "" ]]
  then
    # Running as root? Then become the file owner to remove it.
    if [ $EUID -eq 0 ]
    then
      # Escape spaces for rm to handle paths with spaces.
      # su will have separate environment, so rm can take arguments without having to restore IFS.
      su - $(stat -c %U ${_CORE}) -c "${_ACTION} $(printf %q ${_CORE})"
    else
      # Restore IFS so that rm can handle arguments.
      IFS=${_OLDIFS}
      ${_ACTION} "${_CORE}"
    fi
  fi
done

#eof
